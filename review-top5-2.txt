❯ Again, top 5 from easy to hard

● From the remaining 9:

  1. #3 — # comment vs #private phrasing (§7) — One-sentence rewrite. Change "No #private fields" to acknowledge it's a consequence of # comment syntax.
  2. #5 — No typeof / type reflection — Decision point but straightforward: GPJ is statically typed, so typeof is arguably unnecessary at runtime. Either add it as a runtime operator matching
   JS behavior, or explicitly omit it and note that narrowing is done via type annotations. Either way, a paragraph.
  3. #6 — No iteration protocol — Define what's iterable: Array<T>, String (over codepoints). State Object.keys() returns Array<String>. A few sentences in §5.
  4. #4 — No spread/rest specification — Rest params already work in §6. Formalize: spread in function calls (f(...arr)), array literals ([...a, ...b]), and object literals ({...obj, x: 1}).
  A paragraph with examples.
  5. #9 — toString() and the type system — Needs a design decision: is toString() an implicit method on all types (like Java's Object.toString()) that exists outside the structural type
  surface? Or does every structural type silently include it? Moderate complexity but mostly a matter of stating the rule.

  Remaining 4 (harder): #1 this binding, #2 Vec2 type hole, #7 module resolution, #8 grammar/precedence table — these require heavier design work.

  Want me to start on some of these?

❯ #6, #4 - do whatever mimics JS true spirit.
